{
  "Graph Input": {
    "prefix": "gin",
    "body": [
      "I(n, m);",
      "vvl g(n+1);",
      "",
      "forn(0, m, i){",
      "    I(u, v);",
      "    g[u].pb(v);",
      "    g[v].pb(u);",
      "}"
    ],
    "description": "Takes graph of n nodes and m edges as input (bidirectional)"
  },
  "Tree input": {
    "prefix": "tin",
    "body": [
      "I(n);",
      "vvl g(n+1);",
      "",
      "forn(0, n-1, i){",
      "    I(u, v);",
      "    g[u].pb(v);",
      "    g[v].pb(u);",
      "}"
    ],
    "description": "Take tree of n nodes"
  },
  "Tree input (parent array)": {
    "prefix": "tpin",
    "body": [
      "I(n);",
      "vvl g(n+1);",
      "",
      "forn(2, n+1, i){",
      "    I(x);",
      "    g[x].pb(i);",
      "}"
    ],
    "description": "Take tree of n nodes with parent array of size n-1 (directed)"
  },
  "Vector Input": {
    "prefix": "vin",
    "body": [
      "I(n);",
      "V(ve, n, 0ll);"
    ],
    "description": "Take size of vector and vector as input"
  },
  "Indexed Set": {
    "prefix": "indst",
    "body": [
      "#include <ext/pb_ds/assoc_container.hpp>",
      "using namespace __gnu_pbds;",
      "template<typename T, typename Compare = less<T>>",
      "using indexed_set = __gnu_pbds::tree<T, __gnu_pbds::null_type, Compare, __gnu_pbds::rb_tree_tag, __gnu_pbds::tree_order_statistics_node_update>;"
    ],
    "description": "import indexed set"
  },
  "Modular Arithmetic": {
    "prefix": "mm",
    "body": [
      "ll binExp(ll a, ll b, ll mod = M,ll ans=1) {",
      "    for (; b; b >>= 1, a = a * a % mod)",
      "        if (b & 1) ans = a * ans % mod;",
      "    rt ans;",
      "}",
      "",
      "inline ll ModAdd(ll a, ll b, ll m = M) { rt ((a % m) + (b % m)) % m; }",
      "inline ll ModSub(ll a, ll b, ll m = M) { rt ((a % m) - (b % m) + m) % m; }",
      "inline ll ModMul(ll a, ll b, ll m = M) { rt ((a % m) * (b % m)) % m; }",
      "inline ll ModInv(ll a, ll m = M) { rt binExp(a, M - 2, M); }",
      "inline ll ModDiv(ll a, ll b, ll m = M) { rt ModMul(a, ModInv(b, m), m); }",
      "",
      "inline void cModAdd(ll& a, ll b, ll m = M) { a = ((a % m) + (b % m)) % m; }",
      "inline void cModSub(ll& a, ll b, ll m = M) { a = ((a % m) - (b % m) + m) % m; }",
      "inline void cModMul(ll& a, ll b, ll m = M) { a = ((a % m) * (b % m)) % m; }",
      "inline void cModDiv(ll& a, ll b, ll m = M) { a = ModMul(a, ModInv(b, m), m); }",
      "inline void cModInv(ll& a, ll m = M) { a = binExp(a, M - 2, M); }"
    ],
    "description": "Modular Arithmetic"
  },
  "Factorial": {
    "prefix": "fact",
    "body": [
      "vl fact;",
      "void factorial(ll N){",
      "    fact = move(vec(N, 1ll));",
      "    forn(1, N, i)",
      "    fact[i] = (fact[i-1] * (i%M)) % M;",
      "}"
    ],
    "description": "Precomputes Factorial"
  },
  "IFactorial": {
    "prefix": "ifact",
    "body": [
      "vl inv;",
      "void inverse(ll N){",
      "    inv = move(vec(N, 0ll));",
      "    forn(0, N, i)",
      "    inv[i] = ModInv(i);",
      "}",
      "",
      "vl ifact;",
      "void ifactorial(ll N){",
      "    inverse(N);",
      "    ifact = move(vec(N + 1, 1ll));",
      "    forn(1, N, i)",
      "    ifact[i] = (ifact[i-1] * inv[i]) % M;",
      "}"
    ],
    "description": "Precomputes I Factorial"
  },
  "Inverse from 1 to N": {
    "prefix": "invs",
    "body": [
      "vl inv;",
      "void inverse(ll N){",
      "    inv = move(vec(N, 0ll));",
      "    forn(0, N, i)",
      "    inv[i] = ModInv(i);",
      "}"
    ],
    "description": "Precompute inverse from 1 to N"
  },
  "Low Sieve": {
    "prefix": "lowsi",
    "body": [
      "vl lo;",
      "vl primes;",
      "",
      "void losieve(ll siN){",
      "    lo = move(vec(siN+1, 0ll));",
      "",
      "    forn(0, siN+1, i)",
      "    lo[i] = i;",
      "",
      "    for(int i = 2; i <= siN; i++){",
      "        if (lo[i] == i) primes.pb(i);",
      "        fora(primes, x){",
      "            if (i*x >= siN) break;",
      "            lo[i * x] = x;",
      "            if (!(i % x)) break;",
      "        }",
      "    }",
      "}",
      "",
      "vpl factorise(ll x){",
      "    vpl factors;",
      "    while(x > 1){",
      "        ll cnt = 0;",
      "        ll p = lo[x];",
      "        while(!(x%p)){",
      "            x /= p;",
      "            cnt++;",
      "        }",
      "        factors.pb({p, cnt});",
      "    }",
      "    rt factors;",
      "}"
    ],
    "description": "Precompute Low Sieve"
  },
  "Prefix Sum": {
    "prefix": "presum",
    "body": [
      "vl presum(vl& v){",
      "    vl pre(1, 0);",
      "    fora(v, e) pre.pb(pre.back() + e);",
      "    rt pre;",
      "}"
    ],
    "description": "Function to get Prefix sum"
  },
  "Sieve": {
    "prefix": "si",
    "body": [
      "vector<bool> si;",
      "vl primes;",
      "",
      "void sieve(ll siN){",
      "    si = move(vec(siN+1, true));",
      "    si[0] = si[1] = false;",
      "",
      "    for(int i = 2; i <= siN; i++){",
      "        if (si[i]) primes.pb(i);",
      "        fora(primes, x){",
      "            if (i*x >= siN) break;",
      "            si[i * x] = false;",
      "            if (!(i % x)) break;",
      "        }",
      "    }",
      "}"
    ],
    "description": "Precompute Sieve"
  },
  "Segment Tree (long long) with lazy propagation": {
    "prefix": "segllz",
    "body": [
      "class SegTree {",
      "public:",
      "    vector<ll> seg;",
      "    vector<ll> lz1;",
      "    vector<pair<ll, bool>> lz2;",
      "    ll size;",
      "",
      "    inline ll combine(const ll& a,const ll& b){",
      "        return a + b;",
      "    }",
      "",
      "    void lzp1(ll idx, ll low, ll high){",
      "        if (!lz1[idx]) rt;",
      "        seg[idx] += lz1[idx] * (high - low + 1);",
      "        ",
      "        if (low != high){",
      "            lz1[2*idx+1] += lz1[idx];",
      "            lz1[2*idx+2] += lz1[idx];",
      "        }",
      "        lz1[idx] = 0;",
      "    }",
      "",
      "    void lzp2(ll idx, ll low, ll high){",
      "        if (!lz2[idx].S) rt;",
      "        seg[idx] = lz2[idx].F* (high - low + 1);",
      "",
      "        if (low != high){",
      "            lz2[2*idx+1] = lz2[idx];",
      "            lz2[2*idx+2] = lz2[idx];",
      "            lz1[2*idx+1] = 0;",
      "            lz1[2*idx+2] = 0;",
      "        }",
      "        lz2[idx].S = false;",
      "    }",
      "",
      "    void lzp(ll idx, ll low, ll high){  ",
      "        lzp2(idx, low, high);",
      "        lzp1(idx, low, high);",
      "    }",
      "",
      "    void build(const vector<ll>& ve, ll idx, ll low, ll high) {",
      "        if (low == high) {",
      "            seg[idx] = ve[low];",
      "            return;",
      "        }",
      "        ll mid = (low + high) / 2;",
      "        build(ve, 2*idx+1, low, mid);",
      "        build(ve, 2*idx+2, mid+1, high);",
      "        seg[idx] = combine(seg[2*idx+1], seg[2*idx+2]);",
      "    }",
      "",
      "    pair<ll, bool> query(ll idx, ll low, ll high, ll l, ll r) {",
      "        lzp(idx, low, high);",
      "        if (l <= low && r >= high) return pair(seg[idx], true);",
      "        if (l > high || r < low) return pair(0, false);",
      "",
      "        ll mid = (low + high) / 2;",
      "        pair<ll, bool> left = query(2*idx+1, low, mid, l, r);",
      "        pair<ll, bool> right = query(2*idx+2, mid+1, high, l, r);",
      "",
      "        if (!left.S) return right;",
      "        else if (!right.S) return left;",
      "",
      "        return pair(combine(left.F, right.F), true);",
      "    }",
      "",
      "    void update(ll idx, ll low, ll high, ll k, ll u) {",
      "        lzp(idx, low, high);",
      "        if (low == high) {",
      "            seg[idx] = u;",
      "            return;",
      "        }",
      "        ll mid = (low + high) / 2;",
      "        if (k <= mid) update(2*idx+1, low, mid, k, u);",
      "        else update(2*idx+2, mid+1, high, k, u);",
      "        seg[idx] = combine(seg[2*idx+1], seg[2*idx+2]);",
      "    }",
      "",
      "    void rangeinc(ll idx, ll low, ll high, ll l, ll r, ll x){",
      "        lzp(idx, low, high);",
      "        if (l <= low && r >= high){",
      "            lz1[idx] += x;",
      "            lzp(idx, low, high);",
      "            rt;",
      "        }",
      "        if (l > high || r < low) return;",
      "",
      "        ll mid = (low + high) / 2;",
      "        rangeinc(2*idx+1, low, mid, l, r, x);",
      "        rangeinc(2*idx+2, mid+1, high, l, r, x);",
      "        seg[idx] = combine(seg[2*idx+1], seg[2*idx+2]);",
      "    }",
      "",
      "    void rangeset(ll idx, ll low, ll high, ll l, ll r, ll x){",
      "        lzp(idx, low, high);",
      "        if (l <= low && r >= high){",
      "            lz2[idx] = {x, true};",
      "            lz1[idx] = 0;",
      "            lzp(idx, low, high);",
      "            rt;",
      "        }",
      "        if (l > high || r < low) return;",
      "",
      "        ll mid = (low + high) / 2;",
      "        rangeset(2*idx+1, low, mid, l, r, x);",
      "        rangeset(2*idx+2, mid+1, high, l, r, x);",
      "        seg[idx] = combine(seg[2*idx+1], seg[2*idx+2]);",
      "    }",
      "",
      "    SegTree(const vector<ll>& ve) {",
      "        size = ve.size();",
      "        seg.resize(4*size);",
      "        lz1.resize(4*size);",
      "        lz2.resize(4*size);",
      "        build(ve, 0, 0, size-1);",
      "    }",
      "",
      "    ll query(ll l, ll r) {",
      "        return query(0, 0, size-1, l, r).F;",
      "    }",
      "",
      "    void update(ll k, ll u) {",
      "        update(0, 0, size-1, k, u);",
      "    }",
      "",
      "    void rangeinc(ll l, ll r, ll x){",
      "        rangeinc(0, 0, size-1, l, r, x);",
      "    }",
      "",
      "    void rangeset(ll l, ll r, ll x){",
      "        rangeset(0, 0, size-1, l, r, x);",
      "    }",
      "};"
    ],
    "description": "Segment Tree <long long> class with lazy propagation"
  },
  "Segment Tree": {
    "prefix": "seg",
    "body": [
      "class SegTree {",
      "public:",
      "    vector<ll$0> seg;",
      "    ll size;",
      "",
      "    inline ll$0 combine(const ll$0& a,const ll$0& b){",
      "        return min(a, b);",
      "    }",
      "",
      "    void build(const vector<ll$0>& ve, ll idx, ll low, ll high) {",
      "        if (low == high) {",
      "            seg[idx] = ve[low];",
      "            return;",
      "        }",
      "        ll mid = (low + high) / 2;",
      "        build(ve, 2*idx+1, low, mid);",
      "        build(ve, 2*idx+2, mid+1, high);",
      "        seg[idx] = combine(seg[2*idx+1], seg[2*idx+2]);",
      "    }",
      "",
      "    pair<ll$0, bool> query(ll idx, ll low, ll high, ll l, ll r) {",
      "        if (l <= low && r >= high) return pair(seg[idx], true);",
      "        if (l > high || r < low) return pair(ll$0(), false);",
      "",
      "        ll mid = (low + high) / 2;",
      "        pair<ll$0, bool> left = query(2*idx+1, low, mid, l, r);",
      "        pair<ll$0, bool> right = query(2*idx+2, mid+1, high, l, r);",
      "",
      "        if (!left.S) return right;",
      "        else if (!right.S) return left;",
      "",
      "        return pair(combine(left.F, right.F), true);",
      "    }",
      "",
      "    void update(ll idx, ll low, ll high, ll k, ll$0 u) {",
      "        if (low == high) {",
      "            seg[idx] = u;",
      "            return;",
      "        }",
      "        ll mid = (low + high) / 2;",
      "        if (k <= mid) update(2*idx+1, low, mid, k, u);",
      "        else update(2*idx+2, mid+1, high, k, u);",
      "        seg[idx] = combine(seg[2*idx+1], seg[2*idx+2]);",
      "    }",
      "",
      "    SegTree(const vector<ll$0>& ve) {",
      "        size = ve.size();",
      "        seg.resize(4*size);",
      "        build(ve, 0, 0, size-1);",
      "    }",
      "",
      "    ll$0 query(ll l, ll r) {",
      "        return query(0, 0, size-1, l, r).F;",
      "    }",
      "",
      "    void update(ll k, ll$0 u) {",
      "        update(0, 0, size-1, k, u);",
      "    }",
      "};"
    ],
    "description": "Segment Tree class"
  },
  "Segment Tree (long long)": {
    "prefix": "segll",
    "body": [
      "class SegTree {",
      "public:",
      "    vector<ll> seg;",
      "    ll size;",
      "",
      "    inline ll combine(const ll& a,const ll& b){",
      "        return a + b;",
      "    }",
      "",
      "    void build(const vector<ll>& ve, ll idx, ll low, ll high) {",
      "        if (low == high) {",
      "            seg[idx] = ve[low];",
      "            return;",
      "        }",
      "        ll mid = (low + high) / 2;",
      "        build(ve, 2*idx+1, low, mid);",
      "        build(ve, 2*idx+2, mid+1, high);",
      "        seg[idx] = combine(seg[2*idx+1], seg[2*idx+2]);",
      "    }",
      "",
      "    pair<ll, bool> query(ll idx, ll low, ll high, ll l, ll r) {",
      "        if (l <= low && r >= high) return pair(seg[idx], true);",
      "        if (l > high || r < low) return pair(0, false);",
      "",
      "        ll mid = (low + high) / 2;",
      "        pair<ll, bool> left = query(2*idx+1, low, mid, l, r);",
      "        pair<ll, bool> right = query(2*idx+2, mid+1, high, l, r);",
      "",
      "        if (!left.S) return right;",
      "        else if (!right.S) return left;",
      "",
      "        return pair(combine(left.F, right.F), true);",
      "    }",
      "",
      "    void update(ll idx, ll low, ll high, ll k, ll u) {",
      "        if (low == high) {",
      "            seg[idx] = u;",
      "            return;",
      "        }",
      "        ll mid = (low + high) / 2;",
      "        if (k <= mid) update(2*idx+1, low, mid, k, u);",
      "        else update(2*idx+2, mid+1, high, k, u);",
      "        seg[idx] = combine(seg[2*idx+1], seg[2*idx+2]);",
      "    }",
      "",
      "    SegTree(const vector<ll>& ve) {",
      "        size = ve.size();",
      "        seg.resize(4*size);",
      "        build(ve, 0, 0, size-1);",
      "    }",
      "",
      "    ll query(ll l, ll r) {",
      "        return query(0, 0, size-1, l, r).F;",
      "    }",
      "",
      "    void update(ll k, ll u) {",
      "        update(0, 0, size-1, k, u);",
      "    }",
      "};"
    ],
    "description": "Segment Tree <long long> class"
  },
  "Rabin Karb": {
    "prefix": "rab",
    "body": [
      "class rab{",
      "    public:",
      "    static vvl prepp;",
      "    static vl p;",
      "    static vl m;",
      "    static ll hshcnt;",
      "    static ll RABMAX;",
      "    static bool init;",
      "",
      "    ll n;",
      "    vvl pre;",
      "    ",
      "    rab(str& s){",
      "        if (!init){",
      "            hshcnt = len(p);",
      "            preppCal();",
      "            init = true;",
      "        }",
      "        cal(s);",
      "    };",
      "    ",
      "    static void preppCal(){",
      "        prepp = move(vec(RABMAX, hshcnt, 1ll));",
      "        ",
      "        forn(1, RABMAX, i){",
      "            forn(0, hshcnt, h){",
      "                prepp[i][h] = (prepp[i-1][h] * p[h]) % m[h];",
      "            }",
      "        }",
      "    };",
      "    ",
      "    ll mpp(char& c){",
      "        if (c >= 'a' && c <= 'z') rt c - 'a'+1;",
      "        if (c >= 'A' && c <= 'Z') rt c - 'A'+27;",
      "    }",
      "    ",
      "    void cal(str& s){",
      "        n = len(s);",
      "        pre = move(vec(n+1, hshcnt, 0ll));",
      "",
      "        forn(0, n, i){",
      "            forn(0, hshcnt, h){",
      "                pre[i+1][h] = (pre[i][h] + mpp(s[i]) * prepp[i][h]) % m[h];",
      "            }",
      "        }",
      "    }",
      "",
      "    vl gethash(ll i, ll j){",
      "        vl out(hshcnt);",
      "",
      "        forn(0, hshcnt, h)",
      "        out[h] = (((pre[j+1][h] - pre[i][h] + m[h])%m[h]) * prepp[n-i][h]) % m[h];",
      "",
      "        rt out;",
      "    }",
      "",
      "    vl gethash(str& s){",
      "        vl out(hshcnt);",
      "",
      "        forn(0, len(s), i)",
      "        forn(0, hshcnt, h)",
      "        out[h] = (out[h] + (mpp(s[i]) * prepp[i][h]) % m[h]) % m[h];",
      "",
      "        forn(0, hshcnt, h)",
      "        out[h] = (out[h] * prepp[n][h]) % m[h];",
      "",
      "        rt out;",
      "    }",
      "};",
      "",
      "vvl rab::prepp;",
      "vl rab::p = {31, 37, 53};",
      "vl rab::m = {1000000007, 1000000009, 998244353};",
      "ll rab::hshcnt;",
      "ll rab::RABMAX = 1e6+100;",
      "bool rab::init = false;"
    ],
    "description": "Class to get polynomial hash of substring of a string in O(1) with O(n) precompute"
  },
  "Template": {
    "prefix": "pp",
    "body": [
      "#include <bits/stdc++.h>",
      "using namespace std;",
      "",
      "#define ll long long",
      "#define endl '\\\\n'",
      "#define forn(start, end, var) for(ll var = start; var < end; ++var)",
      "#define forrn(start, end, var) for(ll var = start; var > end; --var)",
      "#define fora(v, var) for(const auto& var: v)",
      "#define rt return",
      "#define F first",
      "#define S second",
      "#define all(v) v.begin(),v.end()",
      "#define _sort(v) sort(all(v))",
      "#define _rsort(v) sort(all(v), greater<decltype(v[0])>())",
      "#define sum(v) accumulate(all(v), 0ll)",
      "#define len(x) x.size()",
      "#define pb push_back",
      "#define get_bit(x,i) (((x) >> (i)) & 1ll)",
      "#define precision(x, p) std::cout << std::fixed << std::setprecision(p) << x << endl;",
      "",
      "const ll M = 1000000007;",
      "const ll inf = (ll)1e15;",
      "",
      "",
      "template <typename C>",
      "constexpr inline int adj(const C& container, int idx) noexcept {",
      "    if (idx < 0) idx += static_cast<int>(container.size());",
      "    assert(idx >= 0 && idx < static_cast<int>(container.size()) && \\\"Invalid Index\\\");",
      "    return idx;",
      "}",
      "",
      "template <typename T>",
      "class MyVector : public vector<T> {",
      "public: ",
      "    using vector<T>::vector;",
      "    MyVector(size_t n, const T& value) : vector<T>(n, value) {}",
      "    T& operator[](int idx) noexcept {rt vector<T>::operator[](adj(*this, idx));}",
      "    const T& operator[](int idx) const noexcept {rt vector<T>::operator[](adj(*this, idx));}",
      "};",
      "",
      "class MyString : public std::string {",
      "public: ",
      "    using string::string;",
      "    MyString(size_t n, const char& c) : string(n, c) {}",
      "    char& operator[](int idx) noexcept {rt string::operator[](adj(*this, idx));}",
      "    const char& operator[](int idx) const noexcept {rt string::operator[](adj(*this, idx));}",
      "};",
      "",
      "using str = MyString;",
      "",
      "template<typename T> using vc = MyVector<T>;",
      "template<typename T> using vvc = vc<vc<T>>;",
      "template<typename T> using vvvc = vc<vvc<T>>;",
      "template<typename T> using vvvvc = vc<vvvc<T>>;",
      "",
      "using pl = pair<ll,ll>;",
      "using vl = vc<ll>;",
      "using vvl = vvc<ll>;",
      "using vvvl = vvvc<ll>;",
      "using vvvvl = vvvvc<ll>;",
      "using vpl = vc<pl>;",
      "using vvpl = vvc<pl>;",
      "using vs = vc<str>;",
      "using vvs = vvc<str>;",
      "",
      "template<typename T>",
      "typename std::enable_if<std::is_arithmetic<T>::value||std::is_same<T,char>::value>::type",
      "inline pim(const T& in,ostream& o,string s=\\\"\\\"){o<<in<<s;}",
      "inline void pim(const str& in,ostream& o,string s=\\\"\\\"){o<<in<<s;}",
      "template<typename T1,typename T2>",
      "inline void pim(const std::pair<T1,T2>& p,ostream& o,string s=\\\"\\\"){o<<'(';pim(p.first,o,\\\", \\\");pim(p.second,o,\\\")\\\");o<<s;}",
      "template<typename T>",
      "typename std::enable_if<std::is_same<decltype(std::begin(std::declval<T>())),decltype(std::end(std::declval<T>()))>::value>::type",
      "inline pim(const T& c,ostream& o,string s=\\\"\\\"){o<<'[';ll n=c.size();fora(c,x){n--;pim(x,o,n?\\\", \\\":\\\"\\\");}o<<\\\"]\\\";o<<s;}",
      "template<typename Fs,typename... R>",
      "inline void pimr(ostream& o, const Fs& f,const R&... r){if constexpr(sizeof...(r)>0){pim(f,o,\\\" \\\");pimr(o,r...);}else{pim(f,o);o<<endl;}}",
      "",
      "template<typename... args>",
      "void print(const args&... r){pimr(cout, r...);};",
      "",
      "",
      "struct custom_hash {",
      "static uint64_t splitmix64(uint64_t x) {",
      "    x += 0x9e3779b97f4a7c15;",
      "    x = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9;",
      "    x = (x ^ (x >> 27)) * 0x94d049bb133111eb;",
      "    return x ^ (x >> 31);",
      "}",
      "size_t operator()(uint64_t x) const {",
      "    static const uint64_t FIXED_RANDOM = chrono::steady_clock::now().time_since_epoch().count();",
      "    return splitmix64(x + FIXED_RANDOM);",
      "}",
      "};",
      "#ifdef ONLINE_JUDGE",
      "#include <ext/pb_ds/assoc_container.hpp>",
      "using namespace __gnu_pbds;",
      "#define um gp_hash_table",
      "#define dbg(x...)",
      "#else",
      "#define um unordered_map",
      "#define dbg(x...) cerr << \\\"[\\\" << #x << \\\"] = \\\"; pimr(cerr, x)",
      "#endif",
      "template<typename Key, typename Value, typename Hash = custom_hash>",
      "using hashmap = um<Key, Value, Hash>;",
      "",
      "",
      "template<typename C>",
      "auto counter(const C& c) -> um<typename C::value_type, ll> {um<typename C::value_type, ll> mp;fora(c, x) ++mp[x];rt mp;}",
      "",
      "template<typename T>",
      "inline auto vec(int n,T in){return MyVector(n, in);}",
      "template<typename... Args>",
      "inline auto vec(int n, Args... args) {return MyVector(n, vec(args...));}",
      "",
      "template<typename T>",
      "inline void fill(T& x){cin >> x;}",
      "template<typename T, typename L>",
      "inline void fill(pair<T, L>& p){fill(p.F);fill(p.S);}",
      "template<typename T>",
      "inline void fill(vc<T>& v){forn(0, v.size(),i)fill(v[i]);}",
      "template<typename... Args, typename T>",
      "inline void fill(T& first, Args&... args) {fill(first);fill(args...);}",
      "",
      "template<typename T>",
      "inline T min(const vc<T>& v) {rt *min_element(all(v));}",
      "template<typename T>",
      "inline T max(const vc<T>& v) {rt *max_element(all(v));}",
      "",
      "template<typename T>",
      "inline int min_idx(const vc<T>& v){rt min_element(all(v))-v.begin();}",
      "template<typename T>",
      "inline int max_idx(const vc<T>& v){rt max_element(all(v))-v.begin();}",
      "",
      "template<typename... Args, typename T>",
      "inline T max(T fs, T sn, Args... a){rt max({fs, sn, a...});}",
      "template<typename... Args, typename T>",
      "inline T min(T fs, T sn, Args... a){rt min({fs, sn, a...});}",
      "",
      "template<typename T, typename... Args>",
      "inline void cmax(T& a, Args... b){ a = max(a, b...); }",
      "template<typename T, typename... Args>",
      "inline void cmin(T& a, Args... b){ a = min(a, b...); }",
      "",
      "#define I(...) ll int __VA_ARGS__; fill(__VA_ARGS__)",
      "#define STR(...) str __VA_ARGS__; fill(__VA_ARGS__)",
      "#define V(x, ...) auto x = move(vec(__VA_ARGS__)); fill(x)",
      "",
      "template<typename T, typename R>",
      "inline void prc(bool con, const T& yes, const R& no){",
      "    if (con) print(yes);",
      "    else print(no);",
      "}",
      "",
      "template<typename T>",
      "inline void pra(vc<T>& ve, ll l = 0, ll r = -1){",
      "    if (r == -1) r = len(ve);",
      "    forn(l, r, i) cout << ve[i] << \\\" \\\";",
      "    cout << endl;",
      "}",
      "",
      "void precalc(){",
      "",
      "}",
      "",
      "void solve(){",
      "",
      "    $0",
      "",
      "}",
      "",
      "int main(){",
      "    ios_base::sync_with_stdio(false);",
      "    cin.tie(NULL);",
      "    ll t=1;",
      "    cin>>t;",
      "    precalc();",
      "    while(t--){",
      "        solve();",
      "    }",
      "    rt 0;",
      "}"
    ],
    "description": "My cpp template"
  },
  "binary lifting": {
    "prefix": "blift",
    "body": [
      "ll ulg = __lg(n)+1;",
      "vvl up = move(vec(n, ulg, 0ll));",
      "",
      "auto blift = [&](auto&& self, ll node, ll par) -> void {",
      "    up[node][0] = par;",
      "    ",
      "    fora(g[node], c){",
      "        if (c == par) continue;",
      "        self(self, c, node);",
      "    }",
      "",
      "};",
      "blift(blift, 1, 0);",
      "",
      "forn(1, ulg, i){",
      "    forn(1, n, node)",
      "    up[node][i] = up[up[node][i-1]][i-1];",
      "}"
    ],
    "description": "Output binary lifting vector"
  },
  "Distance nodes (a, b) in tree": {
    "prefix": "tdis",
    "body": [
      "ll ulg = __lg(n)+1;",
      "vvl up = move(vec(n + 1, ulg, 0ll));",
      "vl tin(n+1, -1), tout(n+1, -1);",
      "vl depth(n+1, inf);",
      "ll timer;",
      "",
      "auto blift = [&](auto&& self, ll node, ll par, ll dep) -> void {",
      "    tin[node] = timer;",
      "    up[node][0] = par;",
      "    depth[node] = dep;",
      "",
      "    fora(g[node], c){",
      "        timer++;",
      "        if (c != par)",
      "        self(self, c, node, dep + 1);",
      "    }",
      "",
      "    tout[node] = timer;",
      "",
      "};",
      "blift(blift, 1, 0, 0);",
      "",
      "forn(1, ulg, i){",
      "    forn(1, n, node)",
      "    up[node][i] = up[up[node][i-1]][i-1];",
      "}",
      "",
      "tin[0] = -inf;",
      "tout[0] = inf;",
      "auto ancestor = [&](ll u, ll v){",
      "    rt (tin[u] <= tin[v] && tout[u] >= tout[v]);",
      "};",
      "",
      "auto lca = [&](ll u, ll v){",
      "    if (ancestor(u, v)) rt u;",
      "    if (ancestor(v, u)) rt v;",
      "",
      "    forrn(ulg-1, -1, i){",
      "        if (!ancestor(up[u][i], v))",
      "        u = up[u][i];",
      "    }",
      "    rt up[u][0];",
      "};",
      "",
      "auto getdis = [&](ll u, ll v){",
      "    rt depth[u] + depth[v] - 2*depth[lca(u, v)];",
      "};"
    ],
    "description": "Get Distance between 2 nodes in a tree in O(logn)"
  },
  "Lowest Common Ancestor of tree": {
    "prefix": "lca",
    "body": [
      "ll ulg = __lg(n)+1;",
      "vvl up = move(vec(n, ulg, 0ll));",
      "vl tin(n+1, -1), tout(n+1, -1);",
      "ll timer;",
      "",
      "auto blift = [&](auto&& self, ll node, ll par) -> void {",
      "    tin[node] = timer;",
      "    up[node][0] = par;",
      "    ",
      "    fora(g[node], c){",
      "        if (c == par) continue;",
      "        self(self, c, node);",
      "    }",
      "",
      "    tout[node] = timer;",
      "};",
      "blift(blift, 1, 0);",
      "",
      "forn(1, ulg, i){",
      "    forn(1, n, node)",
      "    up[node][i] = up[up[node][i-1]][i-1];",
      "}",
      "",
      "tin[0] = -inf;",
      "tout[0] = inf;",
      "auto ancestor = [&](ll u, ll v){",
      "    rt (tin[u] <= tin[v] && tout[u] >= tout[v]);",
      "};",
      "",
      "auto lca = [&](ll u, ll v){",
      "    if (ancestor(u, v)) rt u;",
      "    if (ancestor(v, u)) rt v;",
      "",
      "    forrn(ulg-1, -1, i){",
      "        if (!ancestor(up[u][i], v))",
      "        u = up[u][i];",
      "    }",
      "    rt up[u][0];",
      "};"
    ],
    "description": "Get lca of two nodes in O(logn)"
  },
  "Topological Sort": {
    "prefix": "toposort",
    "body": [
      "vl topa;",
      "auto topo = [&](){",
      "    ll n = len(g);",
      "    topa.clear();",
      "    vector<bool> vis(n, false);",
      "    auto dfs = [&](auto&& self, ll node, ll par) -> void {",
      "        if (vis[node]) rt;",
      "        vis[node] = true;",
      "        fora(g[node], c){",
      "            if (c == par) continue;",
      "            self(self, c, node);",
      "        }",
      "        topa.pb(node);",
      "    };",
      "",
      "    forn(1, n, i)",
      "    dfs(dfs, i, i);",
      "",
      "    reverse(all(topa));",
      "};",
      "topo();"
    ],
    "description": "Output toposort array for graph g"
  }
}